{
    "genesis_time": "2024-02-08T00:17:23.342520258Z",
    "chain_id": "xian-testnet-1",
    "initial_height": "0",
    "consensus_params": {
        "block": {
            "max_bytes": "22020096",
            "max_gas": "-1",
            "time_iota_ms": "1000"
        },
        "evidence": {
            "max_age_num_blocks": "100000",
            "max_age_duration": "172800000000000",
            "max_bytes": "1048576"
        },
        "validator": {
            "pub_key_types": [
                "ed25519"
            ]
        },
        "version": {}
    },
    "validators": [
        {
            "address": "614EBE42CBE8354F733851F4316D0DE316B1AEF0",
            "pub_key": {
                "type": "tendermint/PubKeyEd25519",
                "value": "f6SWyiQ45IfMRaiif9lbLv43MiP3tyho+6sgXWhr5I4="
            },
            "power": "10",
            "name": ""
        },
        {
            "address": "5C7B6531A88A6C6941A7AA495AF041394F8345F0",
            "pub_key": {
                "type": "tendermint/PubKeyEd25519",
                "value": "3/XVTZw82wTSecPAoSPWpzqU4HJdfqyVX9+HKY2+RaY="
            },
            "power": "10",
            "name": ""
        },
        {
            "address": "7D608D056AE761CE4DAE0EE173DFC67E77BC5A1E",
            "pub_key": {
                "type": "tendermint/PubKeyEd25519",
                "value": "bSR2zWb6J3tgd8ds3NknMwQNraLhKijD67CK9E4SvnY="
            },
            "power": "10",
            "name": ""
        },
        {
            "address": "06D833910C79C812F2EF9E062B9B6C606F4FB6A7",
            "pub_key": {
                "type": "tendermint/PubKeyEd25519",
                "value": "tNGWfmJku81h/Uh8rzyvr/3DS+MdCZS/Aq/cwgVsBTw="
            },
            "power": "10",
            "name": ""
        },
        {
            "address": "11229B390E075EE873A279CE85A978E3DE4938AA",
            "pub_key": {
                "type": "tendermint/PubKeyEd25519",
                "value": "2yGnMTdnLwdfmo7hQqGqSDml3rKO8DoQ8+fhbIfbjyQ="
            },
            "power": "10",
            "name": ""
        }
    ],
    "app_hash": "",
    "abci_genesis": {
        "hash": "2bb4e112aca11805538842bd993470f18f337797ec3f2f6ab02c47385caf088e",
        "number": "0",
        "genesis": [
            {
                "key": "currency.__code__",
                "value": "__balances = Hash(default_value=0, contract='currency', name='balances')\n__metadata = Hash(contract='currency', name='metadata')\n__permits = Hash(contract='currency', name='permits')\n__streams = Hash(contract='currency', name='streams')\nSENDER_KEY = 'sender'\nRECEIVER_KEY = 'receiver'\nSTATUS_KEY = 'status'\nBEGIN_KEY = 'begins'\nCLOSE_KEY = 'closes'\nRATE_KEY = 'rate'\nCLAIMED_KEY = 'claimed'\nSTREAM_ACTIVE = 'active'\nSTREAM_FINALIZED = 'finalized'\nSTREAM_FORFEIT = 'forfeit'\n\n\ndef ____(vk: str):\n    __balances[vk] = decimal('5555555.55')\n    __balances['team_lock'] = decimal('16666666.65')\n    __balances['dao'] = decimal('33333333.3')\n    __balances[vk] += decimal('49999999.95')\n    __balances[vk] += decimal('5555555.55')\n    __setup_seed_stream('team_lock', 'team_lock', vk, decimal(\n        '0.10575725568804825'), 1824)\n\n\ndef __setup_seed_stream(stream_id: str, sender: str, receiver: str, rate:\n    float, duration_days: int):\n    __streams[stream_id, 'status'] = 'active'\n    __streams[stream_id, 'begins'] = now\n    __streams[stream_id, 'closes'] = now + datetime.timedelta(days=\n        duration_days)\n    __streams[stream_id, 'receiver'] = receiver\n    __streams[stream_id, 'sender'] = sender\n    __streams[stream_id, 'rate'] = rate\n    __streams[stream_id, 'claimed'] = 0\n\n\n@__export('currency')\ndef transfer(amount: float, to: str):\n    assert amount > 0, 'Cannot send negative balances.'\n    assert __balances[ctx.caller] >= amount, 'Not enough coins to send.'\n    __balances[ctx.caller] -= amount\n    __balances[to] += amount\n\n\n@__export('currency')\ndef approve(amount: float, to: str):\n    assert amount > 0, 'Cannot send negative balances.'\n    __balances[ctx.caller, to] += amount\n\n\n@__export('currency')\ndef transfer_from(amount: float, to: str, main_account: str):\n    assert amount > 0, 'Cannot send negative balances.'\n    assert __balances[main_account, ctx.caller\n        ] >= amount, f'Not enough coins approved to send. You have {__balances[main_account, ctx.caller]} and are trying to spend {amount}'\n    assert __balances[main_account] >= amount, 'Not enough coins to send.'\n    __balances[main_account, ctx.caller] -= amount\n    __balances[main_account] -= amount\n    __balances[to] += amount\n\n\n@__export('currency')\ndef permit(owner: str, spender: str, value: float, deadline: dict,\n    signature: str):\n    permit_msg = __construct_permit_msg(owner, spender, value, deadline)\n    permit_hash = hashlib.sha3(permit_msg)\n    assert __permits[permit_hash] is None, 'Permit can only be used once.'\n    assert now < deadline, 'Permit has expired.'\n    assert crypto.verify(owner, permit_msg, signature), 'Invalid signature.'\n    __balances[owner, spender] += value\n    __permits[permit_hash] = True\n    return f'Permit granted for {value} to {spender} from {owner}'\n\n\ndef __construct_permit_msg(owner: str, spender: str, value: float, deadline:\n    dict):\n    return f'{owner}:{spender}:{value}:{deadline}:{ctx.this}'\n\n\n@__export('currency')\ndef create_stream(receiver: str, rate: float, begins: dict, closes: dict):\n    sender = ctx.caller\n    stream_id = __perform_create_stream(sender, receiver, rate, begins, closes)\n    return stream_id\n\n\ndef __perform_create_stream(sender: str, receiver: str, rate: float, begins:\n    dict, closes: dict):\n    stream_id = hashlib.sha3(f'{sender}:{receiver}:{begins}:{closes}:{rate}')\n    assert __streams[stream_id, STATUS_KEY] is None, 'Stream already exists.'\n    assert begins < closes, 'Stream cannot begin after the close date.'\n    assert rate > 0, 'Rate must be greater than 0.'\n    __streams[stream_id, STATUS_KEY] = STREAM_ACTIVE\n    __streams[stream_id, BEGIN_KEY] = begins\n    __streams[stream_id, CLOSE_KEY] = closes\n    __streams[stream_id, RECEIVER_KEY] = receiver\n    __streams[stream_id, SENDER_KEY] = sender\n    __streams[stream_id, RATE_KEY] = rate\n    __streams[stream_id, CLAIMED_KEY] = 0\n    return stream_id\n\n\n@__export('currency')\ndef create_stream_from_permit(sender: str, receiver: str, rate: float,\n    begins: dict, closes: dict, deadline: dict, signature: str):\n    assert now < deadline, 'Permit has expired.'\n    permit_msg = __construct_stream_permit_msg(sender, receiver, rate,\n        begins, closes, deadline)\n    permit_hash = hashlib.sha3(permit_msg)\n    assert __permits[permit_hash] is None, 'Permit can only be used once.'\n    assert crypto.verify(sender, permit_msg, signature), 'Invalid signature.'\n    __permits[permit_hash] = True\n    return __perform_create_stream(sender, receiver, rate, begins, closes)\n\n\n@__export('currency')\ndef balance_stream(stream_id: str):\n    assert __streams[stream_id, STATUS_KEY], 'Stream does not exist.'\n    assert __streams[stream_id, STATUS_KEY\n        ] == STREAM_ACTIVE, 'You can only balance active streams.'\n    assert now > __streams[stream_id, BEGIN_KEY], 'Stream has not started yet.'\n    sender = __streams[stream_id, SENDER_KEY]\n    receiver = __streams[stream_id, RECEIVER_KEY]\n    assert ctx.caller in [sender, receiver\n        ], 'Only sender or receiver can balance a stream.'\n    closes = __streams[stream_id, CLOSE_KEY]\n    begins = __streams[stream_id, BEGIN_KEY]\n    rate = __streams[stream_id, RATE_KEY]\n    claimed = __streams[stream_id, CLAIMED_KEY]\n    outstanding_balance = __calc_outstanding_balance(begins, closes, rate,\n        claimed)\n    assert outstanding_balance > 0, 'No amount due on this stream.'\n    claimable_amount = __calc_claimable_amount(outstanding_balance, sender)\n    __balances[sender] -= claimable_amount\n    __balances[receiver] += claimable_amount\n    __streams[stream_id, CLAIMED_KEY] += claimable_amount\n    return f'Claimed {claimable_amount} tokens from stream'\n\n\n@__export('currency')\ndef change_close_time(stream_id: str, new_close_time: dict):\n    assert __streams[stream_id, STATUS_KEY], 'Stream does not exist.'\n    assert __streams[stream_id, STATUS_KEY\n        ] == STREAM_ACTIVE, 'Stream is not active.'\n    sender = __streams[stream_id, SENDER_KEY]\n    assert ctx.caller == sender, 'Only sender can extend the close time of a stream.'\n    if new_close_time < __streams[stream_id, BEGIN_KEY] and now < __streams[\n        stream_id, BEGIN_KEY]:\n        __streams[stream_id, CLOSE_KEY] = __streams[stream_id, BEGIN_KEY]\n    elif new_close_time <= now:\n        __streams[stream_id, CLOSE_KEY] = now\n    else:\n        __streams[stream_id, CLOSE_KEY] = new_close_time\n    return f'Changed close time of stream to {__streams[stream_id, CLOSE_KEY]}'\n\n\n@__export('currency')\ndef finalize_stream(stream_id: str):\n    assert __streams[stream_id, STATUS_KEY], 'Stream does not exist.'\n    assert __streams[stream_id, STATUS_KEY\n        ] == STREAM_ACTIVE, 'Stream is not active.'\n    sender = __streams[stream_id, 'sender']\n    receiver = __streams[stream_id, 'receiver']\n    assert ctx.caller in [sender, receiver\n        ], 'Only sender or receiver can finalize a stream.'\n    begins = __streams[stream_id, BEGIN_KEY]\n    closes = __streams[stream_id, CLOSE_KEY]\n    rate = __streams[stream_id, RATE_KEY]\n    claimed = __streams[stream_id, CLAIMED_KEY]\n    assert now <= closes, 'Stream has not closed yet.'\n    outstanding_balance = __calc_outstanding_balance(begins, closes, rate,\n        claimed)\n    assert outstanding_balance == 0, 'Stream has outstanding balance.'\n    __streams[stream_id, STATUS_KEY] = STREAM_FINALIZED\n    return f'Finalized stream {stream_id}'\n\n\n@__export('currency')\ndef close_balance_finalize(stream_id: str):\n    change_close_time(stream_id=stream_id, new_close_time=now)\n    balance_finalize(stream_id=stream_id)\n\n\n@__export('currency')\ndef balance_finalize(stream_id: str):\n    balance_stream(stream_id=stream_id)\n    finalize_stream(stream_id=stream_id)\n\n\n@__export('currency')\ndef forfeit_stream(stream_id: str):\n    assert __streams[stream_id, STATUS_KEY], 'Stream does not exist.'\n    assert __streams[stream_id, STATUS_KEY\n        ] == STREAM_ACTIVE, 'Stream is not active.'\n    receiver = __streams[stream_id, RECEIVER_KEY]\n    assert ctx.caller == receiver, 'Only receiver can forfeit a stream.'\n    __streams[stream_id, STATUS_KEY] = STREAM_FORFEIT\n    __streams[stream_id, CLOSE_KEY] = now\n    return f'Forfeit stream {stream_id}'\n\n\ndef __calc_outstanding_balance(begins: dict, closes: dict, rate: float,\n    claimed: float):\n    claimable_end_point = now if now < closes else closes\n    claimable_period = claimable_end_point - begins\n    claimable_seconds = claimable_period.seconds\n    amount_due = rate * claimable_seconds - claimed\n    return amount_due\n\n\ndef __calc_claimable_amount(amount_due: float, sender: str):\n    return amount_due if amount_due < __balances[sender] else __balances[sender\n        ]\n\n\ndef __construct_stream_permit_msg(sender: str, receiver: str, rate: float,\n    begins: dict, closes: dict, deadline: dict):\n    return (\n        f'{sender}:{receiver}:{rate}:{begins}:{closes}:{deadline}:{ctx.this}')\n"
            },
            {
                "key": "currency.__developer__",
                "value": "sys"
            },
            {
                "key": "currency.__submitted__",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "currency.balances:dao",
                "value": {
                    "__fixed__": "33333333.3"
                }
            },
            {
                "key": "currency.balances:e9e8aad29ce8e94fd77d9c55582e5e0c57cf81c552ba61c0d4e34b0dc11fd931",
                "value": {
                    "__fixed__": "61111111.05"
                }
            },
            {
                "key": "currency.balances:team_lock",
                "value": {
                    "__fixed__": "16666666.65"
                }
            },
            {
                "key": "currency.streams:team_lock:begins",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "currency.streams:team_lock:claimed",
                "value": 0
            },
            {
                "key": "currency.streams:team_lock:closes",
                "value": {
                    "__time__": [
                        2029,
                        5,
                        27,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "currency.streams:team_lock:rate",
                "value": {
                    "__fixed__": "0.10575725568804825"
                }
            },
            {
                "key": "currency.streams:team_lock:receiver",
                "value": "e9e8aad29ce8e94fd77d9c55582e5e0c57cf81c552ba61c0d4e34b0dc11fd931"
            },
            {
                "key": "currency.streams:team_lock:sender",
                "value": "team_lock"
            },
            {
                "key": "currency.streams:team_lock:status",
                "value": "active"
            },
            {
                "key": "dao.S:motion_delay",
                "value": {
                    "__delta__": [
                        1,
                        0
                    ]
                }
            },
            {
                "key": "dao.S:motion_period",
                "value": {
                    "__delta__": [
                        1,
                        0
                    ]
                }
            },
            {
                "key": "dao.S:nays",
                "value": 0
            },
            {
                "key": "dao.S:yays",
                "value": 0
            },
            {
                "key": "dao.__code__",
                "value": "import currency\nimport election_house\n__S = Hash(contract='dao', name='S')\n__pending_motions = Variable(contract='dao', name='pending_motions')\n\n\ndef ____():\n    __S['motion_period'] = datetime.DAYS * 1\n    __S['motion_delay'] = datetime.DAYS * 1\n    __pending_motions.set({'pending_motions': []})\n    __reset()\n\n\n@__export('dao')\ndef current_value():\n    return __pending_motions.get()['pending_motions']\n\n\n@__export('dao')\ndef vote(vk: str, obj: list):\n    __finalize_pending_motions()\n    assert isinstance(obj, list), 'Pass a list!'\n    if len(obj) == 0:\n        return\n    assert vk in election_house.current_value_for_policy('masternodes'\n        ), 'Not a member.'\n    if __S['motion_start'] is None:\n        recipient_vk, amount = obj\n        __assert_recipient_vk_and_amount_is_valid(recipient_vk, amount)\n        __S['recipient_vk'] = recipient_vk\n        __S['amount'] = amount\n        __S['motion_start'] = now\n    else:\n        if now - __S['motion_start'] >= __S['motion_period']:\n            __reset()\n            return\n        position, = obj\n        __assert_vote_is_valid(vk, position)\n        __S['positions', vk] = position\n        if position:\n            __S['yays'] += 1\n        else:\n            __S['nays'] += 1\n        total_votes = __S['yays'] + __S['nays']\n        if total_votes >= len(election_house.current_value_for_policy(\n            'masternodes')) * 3 // 5 + 1:\n            if __S['yays'] >= total_votes * 7 // 10 + 1:\n                __pass_motion()\n            elif __S['nays'] >= total_votes * 7 // 10 + 1:\n                __reset()\n\n\ndef __pass_motion():\n    motions = __pending_motions.get()['pending_motions']\n    motions += [{'motion_passed': now, 'recipient_vk': __S['recipient_vk'],\n        'amount': __S['amount']}]\n    __pending_motions.set({'pending_motions': motions})\n    __reset()\n\n\ndef __finalize_pending_motions():\n    motions = __pending_motions.get()['pending_motions']\n    for motion in motions[:]:\n        if now - motion['motion_passed'] >= __S['motion_delay']:\n            currency.transfer(amount=motion['amount'], to=motion[\n                'recipient_vk'])\n            motions.remove(motion)\n    __pending_motions.set({'pending_motions': motions})\n\n\ndef __reset():\n    __S['yays'] = 0\n    __S['nays'] = 0\n    __S['motion_start'] = None\n    __S['recipient_vk'] = None\n    __S['amount'] = None\n    __S.clear('positions')\n\n\ndef __assert_recipient_vk_and_amount_is_valid(vk: str, amount: int):\n    assert vk is not None, 'No recipient VK provided.'\n    assert isinstance(vk, str), 'Recipient VK is not a string.'\n    assert len(vk) == 64, 'Recipient VK is not 64 characters.'\n    int(vk, 16)\n    assert amount is not None, 'No amount provided.'\n    assert isinstance(amount, int), 'Amount is not an integer.'\n    assert amount > 0, 'Amount is not greater than zero.'\n\n\ndef __assert_vote_is_valid(vk: str, position: bool):\n    assert __S['positions', vk] is None, 'VK already voted.'\n    assert isinstance(position, bool), 'Invalid position.'\n"
            },
            {
                "key": "dao.__developer__",
                "value": "sys"
            },
            {
                "key": "dao.__owner__",
                "value": "election_house"
            },
            {
                "key": "dao.__submitted__",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "dao.pending_motions",
                "value": {
                    "pending_motions": []
                }
            },
            {
                "key": "elect_masternodes.__code__",
                "value": "import currency\nimport election_house\n__candidate_state = Hash(contract='elect_masternodes', name='candidate_state')\n__top_candidate = Variable(contract='elect_masternodes', name='top_candidate')\n__no_confidence_state = Hash(contract='elect_masternodes', name=\n    'no_confidence_state')\n__last_candidate = Variable(contract='elect_masternodes', name='last_candidate'\n    )\n__to_be_relinquished = Variable(contract='elect_masternodes', name=\n    'to_be_relinquished')\nSTAMP_COST = 20\n__member_cost = Variable(contract='elect_masternodes', name='member_cost')\n__controller = Variable(contract='elect_masternodes', name='controller')\n\n\ndef ____(policy: str='members', cost: int=500000):\n    __controller.set(policy)\n    __member_cost.set(cost)\n\n\n@__export('elect_masternodes')\ndef register():\n    assert not __candidate_state['registered', ctx.caller\n        ], 'Already registered.'\n    currency.transfer_from(__member_cost.get(), ctx.this, ctx.caller)\n    __candidate_state['registered', ctx.caller] = True\n    __candidate_state['votes', ctx.caller] = 0\n    if __top_candidate.get() is None:\n        __top_candidate.set(ctx.caller)\n\n\n@__export('elect_masternodes')\ndef unregister():\n    mns = election_house.current_value_for_policy(__controller.get())\n    assert __candidate_state['registered', ctx.caller], 'Not registered.'\n    assert ctx.caller not in mns, \"Can't unstake if in governance.\"\n    currency.transfer(__member_cost.get(), ctx.caller)\n    __candidate_state['registered', ctx.caller] = False\n    __candidate_state['votes', ctx.caller] = 0\n\n\n@__export('elect_masternodes')\ndef vote_candidate(address: str):\n    assert __candidate_state['registered', address\n        ], 'Candidate not registered.'\n    v = __candidate_state['last_voted', ctx.caller]\n    assert v is None or now - v > datetime.DAYS * 1, 'Voting again too soon.'\n    vote_cost = STAMP_COST / election_house.current_value_for_policy(\n        'stamp_cost')\n    currency.transfer_from(vote_cost, 'blackhole', ctx.caller)\n    __candidate_state['last_voted', ctx.caller] = now\n    votes = __candidate_state['votes', address]\n    if votes is None:\n        __candidate_state['votes', address] = 1\n    else:\n        __candidate_state['votes', address] += 1\n    if __top_candidate.get() is not None:\n        if __candidate_state['votes', address] > __candidate_state['votes',\n            __top_candidate.get()]:\n            __top_candidate.set(address)\n\n\n@__export('elect_masternodes')\ndef top_member():\n    return __top_candidate.get()\n\n\n@__export('elect_masternodes')\ndef pop_top():\n    assert ctx.caller == __controller.get(), 'Wrong smart contract caller.'\n    top = top_member()\n    if top is None:\n        return None\n    __candidate_state.clear('votes')\n    __top_candidate.set(None)\n\n\n@__export('elect_masternodes')\ndef vote_no_confidence(address: str):\n    assert address in election_house.current_value_for_policy(__controller.\n        get()), 'Cannot vote against a non-committee member'\n    v = __no_confidence_state['last_voted', ctx.caller]\n    assert v is None or now - v > datetime.DAYS * 1, 'Voting again too soon.'\n    vote_cost = STAMP_COST / election_house.current_value_for_policy(\n        'stamp_cost')\n    currency.transfer_from(vote_cost, 'blackhole', ctx.caller)\n    __no_confidence_state['last_voted', ctx.caller] = now\n    if __no_confidence_state['votes', address] is None:\n        __no_confidence_state['votes', address] = 1\n    else:\n        __no_confidence_state['votes', address] += 1\n    if __last_candidate.get() is None:\n        __last_candidate.set(address)\n    elif __no_confidence_state['votes', address] > __no_confidence_state[\n        'votes', __last_candidate.get()]:\n        __last_candidate.set(address)\n\n\n@__export('elect_masternodes')\ndef last_member():\n    r = __to_be_relinquished.get()\n    if r is not None:\n        return r\n    return __last_candidate.get()\n\n\n@__export('elect_masternodes')\ndef pop_last():\n    assert ctx.caller == __controller.get(), 'Wrong smart contract caller.'\n    r = __to_be_relinquished.get()\n    if r is not None:\n        __no_confidence_state['votes', r] = 0\n        __to_be_relinquished.set(None)\n    else:\n        __no_confidence_state.clear('votes')\n        __candidate_state['registered', __last_candidate.get()] = False\n        __last_candidate.set(None)\n\n\n@__export('elect_masternodes')\ndef force_removal(address: str):\n    assert ctx.caller == __controller.get(), 'Wrong smart contract caller.'\n    __candidate_state['registered', address] = False\n\n\n@__export('elect_masternodes')\ndef relinquish():\n    assert ctx.caller in election_house.current_value_for_policy(__controller\n        .get())\n    r = __to_be_relinquished.get()\n    assert r is None, 'Someone is already trying to relinquish!'\n    __to_be_relinquished.set(ctx.caller)\n"
            },
            {
                "key": "elect_masternodes.__developer__",
                "value": "sys"
            },
            {
                "key": "elect_masternodes.__submitted__",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "elect_masternodes.controller",
                "value": "masternodes"
            },
            {
                "key": "elect_masternodes.member_cost",
                "value": 100000
            },
            {
                "key": "election_house.__code__",
                "value": "I = importlib\n__policies = Hash(contract='election_house', name='policies')\npolicy_interface = [I.Func('vote', args=('vk', 'obj')), I.Func('current_value')\n    ]\n\n\n@__export('election_house')\ndef register_policy(contract: str):\n    if __policies[contract] is None:\n        p = I.import_module(contract)\n        assert I.owner_of(p\n            ) == ctx.this, 'Election house must control the policy contract!'\n        assert I.enforce_interface(p, policy_interface\n            ), 'Policy contract does not follow the correct interface'\n        __policies[contract] = True\n    else:\n        raise Exception('Policy already registered')\n\n\n@__export('election_house')\ndef current_value_for_policy(policy: str):\n    assert __policies[policy] is not None, f'Invalid policy: {policy}.'\n    p = I.import_module(policy)\n    return p.current_value()\n\n\n@__export('election_house')\ndef vote(policy: str, value: Any):\n    assert __policies[policy] is not None, 'Invalid policy.'\n    p = I.import_module(policy)\n    p.vote(vk=ctx.caller, obj=value)\n"
            },
            {
                "key": "election_house.__developer__",
                "value": "sys"
            },
            {
                "key": "election_house.__submitted__",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "election_house.policies:dao",
                "value": true
            },
            {
                "key": "election_house.policies:masternodes",
                "value": true
            },
            {
                "key": "election_house.policies:rewards",
                "value": true
            },
            {
                "key": "election_house.policies:stamp_cost",
                "value": true
            },
            {
                "key": "foundation.__code__",
                "value": "import currency\n__owner = Variable(contract='foundation', name='owner')\n\n\ndef ____(vk: str):\n    __owner.set(vk)\n\n\n@__export('foundation')\ndef withdraw(amount: float):\n    assert amount > 0, 'Cannot send negative balances!'\n    assert ctx.caller == __owner.get(), 'Not owner!'\n    currency.transfer(amount, ctx.caller)\n\n\n@__export('foundation')\ndef change_owner(vk: str):\n    assert ctx.caller == __owner.get(), 'Not owner!'\n    __owner.set(vk)\n"
            },
            {
                "key": "foundation.__developer__",
                "value": "sys"
            },
            {
                "key": "foundation.__submitted__",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "foundation.owner",
                "value": "e9e8aad29ce8e94fd77d9c55582e5e0c57cf81c552ba61c0d4e34b0dc11fd931"
            },
            {
                "key": "masternodes.S:current_motion",
                "value": 0
            },
            {
                "key": "masternodes.S:members",
                "value": [
                    "7fa496ca2438e487cc45a8a27fd95b2efe373223f7b72868fbab205d686be48e",
                    "dff5d54d9c3cdb04d279c3c0a123d6a73a94e0725d7eac955fdf87298dbe45a6",
                    "6d2476cd66fa277b6077c76cdcd92733040dada2e12a28c3ebb08af44e12be76",
                    "b4d1967e6264bbcd61fd487caf3cafaffdc34be31d0994bf02afdcc2056c053c",
                    "db21a73137672f075f9a8ee142a1aa4839a5deb28ef03a10f3e7e16c87db8f24"
                ]
            },
            {
                "key": "masternodes.S:motion_opened",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "masternodes.S:nays",
                "value": 0
            },
            {
                "key": "masternodes.S:yays",
                "value": 0
            },
            {
                "key": "masternodes.__code__",
                "value": "INTRODUCE_MOTION = 'introduce_motion'\nVOTE_ON_MOTION = 'vote_on_motion'\nNO_MOTION = 0\nREMOVE_MEMBER = 1\nADD_SEAT = 2\nREMOVE_SEAT = 3\nVOTING_PERIOD = datetime.DAYS * 1\n__S = Hash(contract='masternodes', name='S')\n__minimum_nodes = Variable(contract='masternodes', name='minimum_nodes')\n__candidate_contract = Variable(contract='masternodes', name=\n    'candidate_contract')\n\n\ndef ____(initial_members: list, minimum: int=1, candidate: str='elect_members'\n    ):\n    __S['members'] = initial_members\n    __minimum_nodes.set(minimum)\n    __candidate_contract.set(candidate)\n    __S['yays'] = 0\n    __S['nays'] = 0\n    __S['current_motion'] = NO_MOTION\n    __S['motion_opened'] = now\n\n\n@__export('masternodes')\ndef quorum_max():\n    return int(len(__S['members']) * 2 / 3) + 1\n\n\n@__export('masternodes')\ndef quorum_min():\n    return min(quorum_max(), __minimum_nodes.get())\n\n\n@__export('masternodes')\ndef current_value():\n    return __S['members']\n\n\n@__export('masternodes')\ndef vote(vk: str, obj: list):\n    assert isinstance(obj, list), 'Pass a list!'\n    arg = None\n    if len(obj) == 3:\n        action, position, arg = obj\n    else:\n        action, position = obj\n    __assert_vote_is_valid(vk, action, position, arg)\n    if action == INTRODUCE_MOTION:\n        __introduce_motion(position, arg)\n    else:\n        assert __S['current_motion'] != NO_MOTION, 'No motion proposed.'\n        if now - __S['motion_opened'] >= VOTING_PERIOD:\n            __reset()\n        assert __S['positions', vk] is None, 'VK already voted.'\n        if position is True:\n            __S['yays'] += 1\n            __S['positions', vk] = position\n        else:\n            __S['nays'] += 1\n            __S['positions', vk] = position\n        if __S['yays'] >= len(__S['members']) // 2 + 1:\n            __pass_current_motion()\n            __reset()\n        elif __S['nays'] >= len(__S['members']) // 2 + 1:\n            __reset()\n\n\ndef __assert_vote_is_valid(vk: str, action: str, position: bool, arg: Any=None\n    ):\n    assert vk in __S['members'], 'Not a member.'\n    assert action in [INTRODUCE_MOTION, VOTE_ON_MOTION], 'Invalid action.'\n    if action == INTRODUCE_MOTION:\n        assert __S['current_motion'] == NO_MOTION, 'Already in motion.'\n        assert 0 < position <= REMOVE_SEAT, 'Invalid motion.'\n        if position == REMOVE_MEMBER:\n            __assert_vk_is_valid(arg)\n    elif action == VOTE_ON_MOTION:\n        assert isinstance(position, bool), 'Invalid position'\n\n\ndef __assert_vk_is_valid(vk: str):\n    assert vk is not None, 'No VK provided.'\n    assert isinstance(vk, str), 'VK not a string.'\n    assert len(vk) == 64, 'VK is not 64 characters.'\n    int(vk, 16)\n\n\ndef __introduce_motion(position: int, arg: Any):\n    assert position <= REMOVE_SEAT, 'Invalid position.'\n    if position == REMOVE_MEMBER:\n        assert arg in __S['members'], 'Member does not exist.'\n        assert len(__S['members']) > __minimum_nodes.get(\n            ), 'Cannot drop below current quorum.'\n        __S['member_in_question'] = arg\n    __S['current_motion'] = position\n    __S['motion_opened'] = now\n\n\ndef __pass_current_motion():\n    current_motion = __S['current_motion']\n    members = __S['members']\n    if current_motion == REMOVE_MEMBER:\n        members.remove(__S['member_in_question'])\n    elif current_motion == ADD_SEAT:\n        member_candidates = importlib.import_module(__candidate_contract.get())\n        new_mem = member_candidates.top_member()\n        if new_mem is not None:\n            members.append(new_mem)\n            member_candidates.pop_top()\n    elif current_motion == REMOVE_SEAT:\n        member_candidates = importlib.import_module(__candidate_contract.get())\n        old_mem = member_candidates.last_member()\n        if old_mem is not None:\n            members.remove(old_mem)\n            member_candidates.pop_last()\n    __S['members'] = members\n\n\ndef __reset():\n    __S['current_motion'] = NO_MOTION\n    __S['member_in_question'] = None\n    __S['yays'] = 0\n    __S['nays'] = 0\n    __S.clear('positions')\n"
            },
            {
                "key": "masternodes.__developer__",
                "value": "sys"
            },
            {
                "key": "masternodes.__owner__",
                "value": "election_house"
            },
            {
                "key": "masternodes.__submitted__",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "masternodes.candidate_contract",
                "value": "elect_masternodes"
            },
            {
                "key": "masternodes.minimum_nodes",
                "value": 1
            },
            {
                "key": "rewards.S:current_votes:blackhole",
                "value": 0
            },
            {
                "key": "rewards.S:current_votes:developer",
                "value": 0
            },
            {
                "key": "rewards.S:current_votes:foundation",
                "value": 0
            },
            {
                "key": "rewards.S:current_votes:masternodes",
                "value": 0
            },
            {
                "key": "rewards.S:election_max_length",
                "value": {
                    "__delta__": [
                        1,
                        0
                    ]
                }
            },
            {
                "key": "rewards.S:master_contract",
                "value": "masternodes"
            },
            {
                "key": "rewards.S:value",
                "value": [
                    {
                        "__fixed__": "0.88"
                    },
                    {
                        "__fixed__": "0.01"
                    },
                    {
                        "__fixed__": "0.01"
                    },
                    {
                        "__fixed__": "0.1"
                    }
                ]
            },
            {
                "key": "rewards.S:vote_count",
                "value": 0
            },
            {
                "key": "rewards.__code__",
                "value": "import election_house\n__S = Hash(contract='rewards', name='S')\n\n\ndef ____(initial_split: list=[decimal('0.88'), decimal('0.01'), decimal(\n    '0.01'), decimal('0.1')], master_contract='masternodes',\n    election_max_length=datetime.DAYS * 1):\n    __S['value'] = initial_split\n    __S['master_contract'] = master_contract\n    __S['election_max_length'] = election_max_length\n    __S['vote_count'] = 0\n    __reset_current_votes()\n\n\ndef __reset_current_votes():\n    __S['current_votes', 'masternodes'] = 0\n    __S['current_votes', 'blackhole'] = 0\n    __S['current_votes', 'foundation'] = 0\n    __S['current_votes', 'developer'] = 0\n\n\n@__export('rewards')\ndef current_value():\n    return __S['value']\n\n\n@__export('rewards')\ndef vote(vk: str, obj: list):\n    if __S['election_start'] is None:\n        total_nodes = len(election_house.current_value_for_policy(__S[\n            'master_contract']))\n        __S['vote_count'] = 0\n        __S['min_votes_required'] = total_nodes * 2 // 3 + 1\n        __S['election_start'] = now\n        __S.clear('has_voted')\n        __reset_current_votes()\n        __tally_vote(vk, obj)\n    else:\n        __tally_vote(vk, obj)\n        if __election_is_over():\n            __update_value()\n            __S['election_start'] = None\n\n\ndef __update_value():\n    masternode_votes = __S['current_votes', 'masternodes'] or 1\n    blackhole_votes = __S['current_votes', 'blackhole'] or 1\n    foundation_votes = __S['current_votes', 'foundation'] or 1\n    developer_votes = __S['current_votes', 'developer'] or 1\n    total_votes = (masternode_votes + blackhole_votes + foundation_votes +\n        developer_votes)\n    mn = masternode_votes / total_votes\n    bh = blackhole_votes / total_votes\n    fd = foundation_votes / total_votes\n    dv = developer_votes / total_votes\n    __S['value'] = [mn, bh, fd, dv]\n\n\ndef __election_is_over():\n    return __S['vote_count'] >= __S['min_votes_required'] or now - __S[\n        'election_start'] >= __S['election_max_length']\n\n\ndef __tally_vote(vk: str, obj: list):\n    __validate_vote(vk, obj)\n    a, b, c, d = obj\n    __S['current_votes', 'masternodes'] += a\n    __S['current_votes', 'blackhole'] += b\n    __S['current_votes', 'foundation'] += c\n    __S['current_votes', 'developer'] += d\n    __S['has_voted', vk] = True\n    __S['vote_count'] += 1\n\n\ndef __validate_vote(vk: str, obj: list):\n    assert vk in election_house.current_value_for_policy(__S['master_contract']\n        ), 'Not allowed to vote!'\n    assert isinstance(obj, list), 'Pass a list!'\n    assert len(obj) == 4, 'Must have 4 elements!'\n    s = 0\n    for o in obj:\n        assert int(o) >= 0, 'No non-negative numbers!'\n        s += o\n    assert s == 100, 'Elements must add to 100!'\n    assert __S['has_voted', vk] is None, 'VK has already voted!'\n"
            },
            {
                "key": "rewards.__developer__",
                "value": "sys"
            },
            {
                "key": "rewards.__owner__",
                "value": "election_house"
            },
            {
                "key": "rewards.__submitted__",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            },
            {
                "key": "stamp_cost.S:current_total",
                "value": 20
            },
            {
                "key": "stamp_cost.S:election_max_length",
                "value": {
                    "__delta__": [
                        1,
                        0
                    ]
                }
            },
            {
                "key": "stamp_cost.S:master_contract",
                "value": "masternodes"
            },
            {
                "key": "stamp_cost.S:value",
                "value": 20
            },
            {
                "key": "stamp_cost.S:vote_count",
                "value": 1
            },
            {
                "key": "stamp_cost.__code__",
                "value": "import election_house\n__S = Hash(contract='stamp_cost', name='S')\n\n\ndef ____(initial_rate: int=100, master_contract='masternodes',\n    election_max_length=datetime.DAYS * 1):\n    __S['value'] = initial_rate\n    __S['master_contract'] = master_contract\n    __S['election_max_length'] = election_max_length\n    __S['vote_count'] = 1\n    __reset_current_votes()\n\n\ndef __reset_current_votes():\n    __S['current_total'] = __S['value']\n\n\n@__export('stamp_cost')\ndef current_value():\n    return __S['value']\n\n\n@__export('stamp_cost')\ndef vote(vk: str, obj: int):\n    if __S['election_start'] is None:\n        total_nodes = len(election_house.current_value_for_policy(__S[\n            'master_contract']))\n        __S['vote_count'] = 1\n        __S['min_votes_required'] = total_nodes * 2 // 3 + 1\n        __S['election_start'] = now\n        __S.clear('has_voted')\n        __reset_current_votes()\n        __tally_vote(vk, obj)\n    else:\n        __tally_vote(vk, obj)\n        if __election_is_over():\n            __update_value()\n            __S['election_start'] = None\n\n\ndef __update_value():\n    __S['value'] = int(__S['current_total'] / __S['vote_count']) or 1\n\n\ndef __election_is_over():\n    return __S['vote_count'] >= __S['min_votes_required'] or now - __S[\n        'election_start'] >= __S['election_max_length']\n\n\ndef __tally_vote(vk: str, obj: int):\n    __validate_vote(vk, obj)\n    __S['current_total'] += obj\n    __S['has_voted', vk] = True\n    __S['vote_count'] += 1\n\n\ndef __validate_vote(vk: str, obj: int):\n    assert vk in election_house.current_value_for_policy(__S['master_contract']\n        ), 'Not allowed to vote!'\n    assert isinstance(obj, int), 'Pass an int!'\n    assert obj > 0, 'No negatives!'\n    assert __S['value'] / 2 <= obj <= __S['value'] * 2, 'Out of range!'\n    assert __S['has_voted', vk] is None, 'Already voted!'\n"
            },
            {
                "key": "stamp_cost.__developer__",
                "value": "sys"
            },
            {
                "key": "stamp_cost.__owner__",
                "value": "election_house"
            },
            {
                "key": "stamp_cost.__submitted__",
                "value": {
                    "__time__": [
                        2024,
                        5,
                        29,
                        11,
                        18,
                        0,
                        0
                    ]
                }
            }
        ],
        "origin": {
            "signature": "c7defff94082601d9389df01a162b1bf4232475e4a5be154733ba55233334da0c2aa5816bbbae7edcc4e08e1259b71387db534a6dbfc505c53757370f2a25306",
            "sender": "e9e8aad29ce8e94fd77d9c55582e5e0c57cf81c552ba61c0d4e34b0dc11fd931"
        }
    }
}